<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8">
<meta name='description' content='A JavaScript tool for multiplying form inputs'>
<meta name='author' content='Joe Golembieski, SoftMoon-WebWare'>
<meta name='copyright' content='Copyright © 2010, 2012, 2013, 2015, 2022, 2023 Joe Golembieski, SoftMoon-WebWare'>
<title>FormFieldGenie instructions from SoftMoon-WebWare</title>
<link rel="icon" type="image/x-icon" href="images/SoftMoonWebWare.gif">
<style type="text/css">
body, header, main, section, footer, figure, div, h1, h2, h4, h5, img, ul, ol, dl, menu, li {
	margin: 0;
	padding: 0; }
body {
	min-width: 57em;
	font-family: serif;
	color: #000000;
	background-color: #FFDEAD;
	background-image:  /* SteelBlue */
		linear-gradient(to right, #4682B4FF, 304px, #4682B400 800px),
		linear-gradient(to bottom, #4682B4FF, 266px, #4682B400 700px),
		linear-gradient(to top, #4682B4FF, 38px, #4682B400 100px);
	}

header h1 {
	font-size: 1.618em;
	font-weight: bold;
	clear: both;
	text-align: center;  }
header h1:first-child {
	font-family: sans-serif;
	padding: .618em 1em 0 1em;
	text-align: left; }
header h1 span {
	padding: 0 0 0 2.618em;
	font-size: .764em }  /* ≈ Φ + ((1-Φ) - (1-Φ)*Φ) */

header figure {
	margin-left: .382rem;
	float: left; }
#logo {
	opacity: .78;
	font-size: 1.618em; /*for alt text*/
	font-weight: bold;
	line-height: 150%; }
header figcaption {
	font-size: 1.382em;
	font-weight: bold;
	text-align: center;
	width: 27em; }
header h1 span,
header figcaption span {
	display: block;
	font-style: oblique; }

main {
	text-align: center; }
main h2 {
	margin-top: 2em; }
main h3 {
	margin: 0; }
main p {
	text-align: justify;
	text-indent: -.618em;
	font-size: 1.236em;
	width: 27em;
	margin: 0 auto 0 auto;
	padding: 0 1em 1em 1em; }
main p * {
	text-indent: 0; }
main p:first-letter {
	font-size: 1.618em;
	font-weight: bold;
	color: #000040; }
main topic {
	font-weight: bold;
	color: black;
	background-color: Chartreuse; }
main p code {
  white-space: nowrap; }
main > code {
	white-space: pre; }
main > code,
main ul,
main dl {
	margin: 0 auto 2em auto;
	font-size: 1.236em;
	display: block;
	text-align: left;
	list-style: none;
	max-width: 47em; }
main dl ul,
main dl dl {
	margin: 0 auto;
	font-size: inherit;
	max-width: 40em; }
main li { margin-top: .618em; }
main ul.bulletted {
	list-style: circle; }
main ul.bulletted li code {
	display: inline;
	white-space: pre; }
main default {
	color: black;
	background-color: Orange;
	border-radius: .382em; }
main dt {
	margin-top: 1em;
	font-weight: bold;
	font-size: 116.2%;
	font-family: monospace; }
main dl dl dt {
	margin: 0; }
main dt code { /*CornflowerBlue, 38% opacity;*/
	background-color: RGBA(100, 149, 237, 38%); }
main p note,
main dd em {
	font-style: oblique;
	color: maroon;
	display: block; }
main dd strong em {
	display: inline; }
main > .notice {
	font-size: 1.236em; }
main > ul + .notice {
	margin: -1.618em auto 1em auto; }
main .notice {
	display: block;
	color: #800000; }
desc,
rule {
	display: block; }
rule {
	margin-left: 1em;
	text-indent: -.382em; }


footer p {
	margin: 0 1.618em;
	font-size: .78em;
	font-weight: bold; }
footer note {
	margin-right: 2.618em; }
footer note:last-child {
	margin-right: 0; }

dd mark,
.numerance {
	font-size: .618em;
	vertical-align: .618em;
	line-height: 100%; }
.macronym {
	display: inline;
	font-size: .763924em;
	vertical-align: .236076em;
	line-height: 100%; }
abbr.macronym {
	font-size: .382em;
	vertical-align: 1.1618em;
	border-bottom: none; }
mark {
	background-color: inherit; }
code, var {
	font-family: monospace; }
kbd span {
	display: inline-block;
	position: relative;
	top: -.162em;
	bottom: auto;
	border: 1px solid #8080FF;
	border-bottom: 2px solid #404080;
	border-right: 2px solid #404080;
	border-radius: 1.618em / 2em;
	color: white;
	background-color: #202040;
	text-align: center;
	margin: 0 .162em;
	padding: 0 .618em;
	font-size: 85.4%;  }
</style>
</head>
<body>
<header>
<h1>Custom Web Software Development</h1>
<figure>
<img id='logo' src="images/SoftMoon-WebWare.gif" alt="SoftMoon-WebWare">
<figcaption>JavaScript<mark class='macronym'>™</mark>, <abbr>HTML 5</abbr>, <abbr>CSS 4</abbr>, &amp; <abbr>PHP 8</abbr>:
<span>Innovative Enterprise level Scripting for interactive sites, <acronym title='software as a service'>SaaS</acronym>, &amp; cross-platform desktop apps</span></figcaption>
</figure>

<h1>FormFieldGenie-4 Text-Input Auto-Pop-Up</h1>
</header>

<main id='content'>
<p>This JavaScript<mark class='macronym'>™</mark> powered multifunctional class allows you to create an
end-user-manipulatable <abbr>HTML</abbr> form
that requires an unknown number of textual-input / file-input form fields.&nbsp; When you don’t want to limit your visitors to a
minimal number of input options, but don’t want your page display to be bloated with a large number of empty user-input boxes,
this is the utility you need.&nbsp;
Since the version 2.2 release, an end-user can even cut, copy, and paste entire
sections of an <abbr>HTML</abbr> form to/from multi-clip clipboards.&nbsp;
We use this class in our
►<a href="https://softmoon-webware.com/MasterColorPicker_instructions.php">MasterColorPicker</a> package,
and you can see useful working integrated examples there
(in the “MyPalette” and “Gradientor” sub-applications, and the “Color Filter” extension).</p>

<p><em>¿What</em> do you use this for?&nbsp; When you have to ask someone to list each of something
you request, and they may need one (1) form field, or they may need fifty (50), or anywhere in between or even more!&nbsp;
Consider asking about someone’s children and grandchildren.&nbsp; In one family there may be two children,
each with one grandchild.&nbsp;
What about a large family with 7 children, each with an average of 5 grandchildren?&nbsp;
Do you create a form that accommodates the large family, forcing the small family to wade through your web page
like trying to navigate swamp water?&nbsp;  And what about the family with 12 children and 78 grandchildren?&nbsp;
Of course there are functions that say &ldquo;click this button to create a new form field&rdquo;.
Clicking once or twice may be OK.&nbsp; I've seen that approach used to upload files,
and it annoyed me when I had to upload two dozen, simply because it broke the &ldquo;flow&rdquo; of selecting each file;
and that was all point and click.&nbsp;
When you have to actually type in a phrase, then switch to the mouse to click, then back to the keyboard...
This is <strong>much</strong> easier — even when an end-user just needs to simply upload an unknown number of files.</p>

<p>The best way to understand this class is to exemplify it, so we created a
►<a href="https://softmoon-webware.com/test_FormFieldGenie-js.php" target="_blank">working demo</a>.&nbsp;
You should also view the highlighted
►<a href="https://softmoon-webware.com/code/test_FormFieldGenie-js_sourcecode.htm" target="_blank">demo source code</a>
to understand what is happening, why and how.&nbsp;
You can download the JavaScript<mark class='macronym'>™</mark> package from our ►<a href='OpenSource.php'>download page</a>
or Git it from GitHub: ►<a href='https://github.com/SoftMoonWebWare/FormFieldGenie' target='github'>FormFieldGenie</a>.</p>

<p>Using this class is simple and straight-forward, requiring only a few
JavaScript<mark class='macronym'>™</mark> event handlers be added to the form field(s)
you want duplicated (cloned).&nbsp;
But it is no simple class: not only can it clone the form field
that the event handlers are attached to, but any associated form fields, their labels,
and any other <acronym>DOM</acronym> nodes that go along.&nbsp;
If the said form-fields are being sent to a server, then the other primary function
this class serves is to <em>update the names</em> of the cloned form-fields and <em>keep them in order</em>
when new fields are “popped,” “pasted,” “inserted,” or “deleted”.&nbsp;
We will attempt to explain its use in terms that
a non-programmer can understand, so you can incorporate this class successfully in your site,
but a basic amount of <abbr>HTML</abbr> understanding and a minimum amount of knowledge on using
JavaScript<mark class='macronym'>™</mark> in your <abbr>HTML</abbr> pages is required.&nbsp;
It has a list of options that allow you to fine-tune the way it works making it incredibly versatile.&nbsp;
Plus it allows plug-in callback functions that allow it infinite flexibility.&nbsp;
It intelligently updates the name associated with each form field cloned based on each individual name;
if your given name is incompatible with this class’ capabilities, your custom plugin can handle it.&nbsp;
And it does all this <strong>without <em>any</em></strong> additional markup to your <abbr>HTML</abbr>.</p>

<h2>To create a new FormFieldGenie instance:</h2>
<code>myGenie=new SoftMoon.WebWare.FormFieldGenie({…options object…}, HTML_clipMenu);</code>

<p>When adding a new form-field or group of form-fields (using the <code>popNewField()</code> method),
the FormFieldGenie can create (clone) one based on what already exists in the form (more on that below),
or you can explicitly give it a form-field or group of form-fields to clone.&nbsp;
You may pass an explicit DOM node (form-field or group of form-fields) to clone
when creating an instance of the FormFieldGenie;&nbsp; for example:</p>
<code>myGenie=new SoftMoon.WebWare.FormFieldGenie({clone: ……my DOM node to clone…… });
myGenie.popNewField(……)</code>

<p>After creating an instance of the FormFieldGenie, you may also
set the instance.config.clone (<code>myGenie.config.clone</code> in these examples) to the explicit <acronym>DOM</acronym> node
(form-field or group of form-fields) you want to clone (if any).&nbsp;
An example of defining an explicit node to clone:</p>
<code>myGenie=new SoftMoon.WebWare.FormFieldGenie({……my options……});
myGenie.config.clone= ……my DOM node to clone……
myGenie.popNewField(………)</code>


<h2>Using the FormFieldGenie</h2>

<p>The first parameter passed to this class’ methods is the entire
<acronym>DOM</acronym> node you want auto-regenerated, deleted, cut, copied, inserted before, or pasted-over.&nbsp;
A quick look at the source code of the demonstration example will help clarify this.&nbsp;
If you only need the form field itself repeated, pass the value of <code>this</code> to the function.&nbsp;
Remember, in an event handler for form fields, the keyword <code>this</code> refers to the
<acronym>DOM</acronym> node of the form-field itself.&nbsp;
If the field has a <code>&lt;label&gt;</code> tag (or any other tag) around it that you want cloned also,
simply pass <code>this.parentNode</code>.&nbsp;
If you want to clone a whole group of fields and associated text,
simply repeat <code>parentNode</code> in a chain as many times as needed to move up the <acronym>DOM</acronym> tree.&nbsp;
<note><strong>Note</strong> that the FormFieldGenie started out as a single simple function
back in the days of dinosaur browsers,
when <code>focusIn</code> &amp; <code>focusOut</code> events (which do bubble) were not standard.&nbsp;
You had to use <code>focus</code> &amp; <code>blur</code> events (which do not bubble)
directly on the <code>&lt;input&gt;</code> ‖ <code>&lt;textarea&gt;</code> Elements,
requiring an event-handler for each that needs to keep track of <code>parentNode</code>s and their “anscestors.”&nbsp;
The demo (test!) example was developed then.&nbsp;
These days you can put the event-handlers on <code>parentNode</code>s and their “ancestors”
(as in the short simple example shown below),
greatly simplyfying the application of this class to your <abbr>HTML</abbr>.</note></p>

<p>From there, the class makes one requirement:
there must be a tag enclosing the <code>fieldNodeGroup</code> (see below) you want cloned.&nbsp;
The clones are added into this enclosing tag.&nbsp; First, let’s be clear that <em>any</em>
<abbr>HTML</abbr> “element” tags may be used; it does not matter to the class.&nbsp;
For the sake of discussion, we will refer to these these as follows:</p>
<ul>
<li>The &lt;input&gt; and &lt;textarea&gt; <acronym>DOM</acronym> <abbr>HTML</abbr> Elements themselves
are referred to as the <topic><code>fieldNode</code></topic>
(only <code>&lt;input&gt;</code> types that are found in the array at <code>instance.config.userDataInputTypes</code>).&nbsp;
A <code>fieldNode</code> needs to have the proper event handlers attached;&nbsp;
alternatively, the event-handlers may be attached to the <code>fieldNodeGroup</code> or the <code>fieldNodeGroupFieldset</code>
or even higher up the document hierarchy, if you manage them correctly.</li>
<li>The entire <acronym>DOM</acronym> <abbr>HTML</abbr> Element node you want cloned
is referred to as the <topic><code>fieldNodeGroup</code></topic>.&nbsp;
It may be as simple as one <code>fieldNode</code> or an Element containing one or more <code>fieldNode</code>s,
descriptive text in a <code>&lt;label&gt;</code>, any other Elements, …whatever you need or like.</li>
<li>The <acronym>DOM</acronym> <abbr>HTML</abbr> Element enclosing the cloned <acronym>DOM</acronym> nodes
is referred to as the <topic><code>fieldNodeGroupFieldset</code></topic></li>
</ul>

<p>In the super-simple example shown below,
the <code>&lt;input&gt;</code> is the <code>fieldNode</code>,
the <code>&lt;label&gt;</code> is the <code>fieldNodeGroup</code>,
and the <code>&lt;fieldset&gt;</code> is the <code>fieldNodeGroupFieldset</code>.&nbsp;
The number <code>1</code> will be updated in the <code>&lt;input&gt;</code>’s <code>name</code> attribute
when the <code>fieldNodeGroup</code> is cloned and the clone is added to the <code>fieldNodeGroupFieldset</code>.&nbsp;
This updated number will be kept in proper sequence (without gaps) with the order of <code>&lt;input&gt;</code>s in the <abbr>HTML</abbr>,
which is generally and accordingly the sequence shown to the end-user.&nbsp;
(Alternatively, with <abbr>PHP</abbr> at least, the name could simply be <code>user[pets][]</code>
and the FormFieldGenie will do nothing to it, because it doesn’t need to! …more on that below…)&nbsp;
<note>Also <strong>note</strong> that the event-handlers could be moved to the <code>&lt;label&gt;</code>
and we could then use the keyword <code>this</code> instead of <code>event.target.parentNode</code>&nbsp;
If we keep them on the <code>&lt;fieldset&gt;</code> they could be attached using <code>addEventListener()</code>
instead of using inline-attributes, as they will not need to be cloned;
the <code>&lt;label&gt;</code> gets cloned, so it is easier to use inline-attributes there
since they get cloned with the Element, whereas “attached EventListeners” do not get cloned.</note></p>

<code>
&lt;fieldset
 onfocusin='myGenie.tabbedOut=false'
 onkeydown='myGenie.catchTab(event)'
 onfocusout='myGenie.popNewField(event.target.parentNode)'&gt;
  &lt;label&gt;pet name&lt;input type='text' name='user[pets][1]'&gt;&lt;/label&gt;
&lt;/fieldset&gt;
</code>

<p>The <code>fieldNodeGroupFieldset</code> may contain any other <abbr>HTML</abbr> besides the clones;
<strong>but</strong> the clones will always be added to the <code>fieldNodeGroupFieldset</code>
directly following the last <code>fieldNodeGroup</code>.&nbsp;
See also the <code>config.groupClass</code> and <code>config.groupTag</code> options
in the <a href='#config_stack'>ConfigStack</a> description below.&nbsp;
Beyond this, you are free to develop your page the way you see fit.&nbsp;</p>

<p>Any time your keyboard cursor is focused on a <code>fieldNode</code> and then you leave it
by pressing the <kbd><span>Tab</span></kbd> key or by clicking the mouse button somewhere else,
the class looks at all the <code>fieldNodeGroup</code>s within <code>fieldNodeGroupFieldset</code>.&nbsp;
If any are empty (except for the <em>last</em> one), by default it deletes them
(you can change this default action with options;
see <code>dumpEmpties()</code> in the <a href='#config_stack'>ConfigStack</a> description below).&nbsp;
It then looks within the last <code>fieldNodeGroup</code> and
by default finds the <em>first</em> text-based <code>&lt;input&gt;</code> tag
(see <code>userDataInputTypes</code> in the <a href='#config_stack'>ConfigStack</a> description below),
or if there are no <code>&lt;input&gt;</code>s, by default finds the <em>first</em> <code>&lt;textarea&gt;</code>,
then looks to see if anything was typed in (or similar for <code>type='file'</code>).&nbsp;
If this <code>fieldNode</code> has been filled by the user,
the class &lsquo;pops’ a new <code>fieldNodeGroup</code>.</p>

<p>If the end-user pressed the <kbd><span>Tab</span></kbd> key from within a <code>fieldNode</code> (to exit it)
and a new <code>fieldNodeGroup</code> was popped, by default
the cursor is focused within a specified <code>fieldNode</code> of the new <code>fieldNodeGroup</code>.&nbsp;
If nothing was popped, the cursor is passed onto the next form field as usual.&nbsp;
If the end-user clicked out of the <code>fieldNode</code>, the usual action is taken depending on where you click,
whether or not a new <code>fieldNodeGroup</code> was popped.</p>

<p>That sums up the main framework of the class.&nbsp;
Its true power begins to shine when you look at how it updates the names associated with each
form field cloned, and how the available options you can pass to the class can modify the default
actions of the main framework and the process of updating the field names.&nbsp;
This gives it the ability to work with virtually any <abbr>HTML</abbr> form of any complexity,
and the corresponding supporting server side script.</p>

<p>When this class updates a name, it considers several things.&nbsp; Is the name indexed, or not?
(i.e. <code>name[index]</code> or <code>name[index][index]</code> etc.)&nbsp; If it is indexed,
is the last index virtual ("implicit")? (i.e. <code>name[]</code> or <code>name[index][]</code> etc.)&nbsp;
Remember in <abbr>PHP</abbr>, when multiple form fields return the same <strong>virtual</strong> ("implicit") indexed name
they are automatically placed into a sequentially numbered array.&nbsp;
If the field’s name is not indexed, this function considers
whether the last characters are numeric digits, or not
(e.g. <code>name</code> or <code>name123</code> etc.).&nbsp;
Remember when a form returns multiple fields of the same name without using virtual ("implicit") indexes,
the last one overwrites all the others when using <abbr>PHP</abbr>.&nbsp;
It should be mentioned here that if these built-in processes for updating the name don’t suit your needs,
you may write your own plug-in that can do anything you want!&nbsp;
(See <code>updateName()</code> in the <a href='#config_stack'>ConfigStack</a> description below.)&nbsp;
The one other thing to be considered when updating the name is a special case involving the
<strong>value</strong> of checkboxes and radio-buttons; this involves reasons similar to those involved when
updating virtually indexed names, and we will take a look at this further down...</p>

<h3>Virtually Indexed Names</h3>
<p>Lets look at these first.&nbsp; There is generally no need to do anything to these names.&nbsp;
The server side script (<abbr>PHP</abbr>) handles them as they should be.&nbsp;
The exception is when you use checkboxes and radio buttons.&nbsp;
Take a look at the source code of the demonstration example and also at the test-demo itself.&nbsp;
Notice how the nickname section uses checkboxes within the <code>fieldNodeGroup</code> to be cloned.&nbsp;
If we simply clone these and leave their names unchanged, the resulting data no longer co-ordinates with
its associate data.&nbsp; You get a sequential array of all the checkboxes checked by the user,
but there is no way to tell which array element corresponds to which nickname.&nbsp;
So checkboxes and radio buttons with virtually indexed names are instead treated as fully indexed names.</p>

<h3>Fully Indexed Names</h3>
<p>The class looks for the <strong>last</strong> index in the name that is <strong>numeric</strong>
and increases it by one for each new field popped.&nbsp; Note this also applies to checkboxes and radio buttons
with virtually indexed names (see the paragraph above).&nbsp;
If no index is found to be numeric, the name is left unchanged.</p>

<h3>Non-indexed Names</h3>
<p>Non-indexed names without digits at the end are simply left alone.&nbsp;
This is generally only useful for radio buttons or <code>&lt;button&gt;</code> Elements.&nbsp;
Names that end in a sequence of digits have that sequence numerically increased by one for each new field popped.&nbsp;
Pay close attention to the favorite cars example and the data it produces when the form is submitted.&nbsp;
Note how only the last sequence of digits is increased, and the rest are left alone.</p>

<h3>Special case: checkboxes and radio buttons with &ldquo;indexed&rdquo; <em>values</em></h3>
<p>In some cases the need arises for the <strong>value</strong> of these form fields to be updated, not the name.&nbsp;
The favorite pets section in the demonstration exemplifies this.&nbsp;
If the <strong>value</strong> is a number within square brackets
(i.e. <code>[0]</code> or <code>[1]</code> or <code>[1756]</code> etc.)
it can be updated <strong>instead</strong> of the name.&nbsp;
Furthermore, you can control what style name (virtual, indexed, non-indexed, or combinations)
allows updating the value; while allowing flexibility, this becomes truly invaluable when
<code>fieldNodeGroup</code>s are nested within each other.&nbsp;
To control this using user-options, see <code>updateValue</code> in the <a href='#config_stack'>FormFieldGenie.ConfigStack</a> description.</p>

<h2>Coping, Cutting, Pasting, &amp; Inserting</h2>
<p>You can paste <strong>two</strong> different ways using <strong>three</strong> different methods:</p>
<ul class='bulletted'>
		<li>paste over an existing <code>fieldNodeGroup</code> using <code>pasteField(fieldNodeGroup, {clip: %%your-clip-reference%%})</code></li>
		<li>insert a new <code>fieldNodeGroup</code> using <code>pasteField(fieldNodeGroup, {doso: 'insert', clip: %%your-clip-reference%%})</code></li>
		<li>insert a new <code>fieldNodeGroup</code> using <code>popNewField(fieldNodeGroup, {doso: 'paste', clip: %%your-clip-reference%%})</code></li>
</ul>
<span class='notice'>( see “clip” in “<a href='#options'>options</a>” below for more info on <var>%%your-clip-reference%%</var> )</span>
<p>The difference between <code>popNewField()</code> and <code>pasteField()</code>
is that <code>pasteField()</code> will return <code>false</code> if the clip is empty,
while <code>popNewField()</code> will simply pop a new “blank” clone if the clip is empty.&nbsp;
After creating an instance of the FormFieldGenie,
the clipboard Object may be accessed through <code>instance.clipboard</code>;&nbsp;
each clipboard Object property may contain an individual clip (<acronym>DOM</acronym> node).&nbsp;
For more details, see the “<a href='#options'>options</a>” description below.</p>

<p>The <topic><code>HTML_clipMenu</code></topic> is passed in as the second parameter when creating an instance of the FormFieldGenie.&nbsp;
Find it / modify it as the property: <code>myGenie.HTML_clipMenu</code> of your FormFieldGenie instance.&nbsp;
It should be an actual snippet of <abbr>HTML</abbr>.&nbsp;
In the example shown below, we would do something like:</p>
<code>myGenie=new SoftMoon.WebWare.FormFieldGenie({…options…}, document.getElementById('myGenie_popUpMenu'));</code>
<p>It is used when you want to allow your end-users the ability to cut/copy/paste/delete
entire form sections (<code>fieldNodeGroups</code> — when copied/cut we call them “clips”)
and would look something like the example below.&nbsp;
Note that the <code>standardItems</code> attribute holds the classname given to <code>&lt;li&gt;</code> Elements
that do not get deleted.&nbsp;
The FormFieldGenie will update the HTML by adding/deleting <code>&lt;li&gt;</code> Elements that reference copied/cut “clips.”</p>

<p>You may copy and paste this snippit of HTML into your web-page – one copy per Genie instance.&nbsp;
You may change/add any <code>id</code> or <code>class</code> names to this HTML for CSS handles.&nbsp;
You may modify the <code>&lt;li&gt;TEXT&lt;/li&gt;</code> in the outer <code>&lt;menu&gt;</code> but not the inner <code>&lt;ul&gt;</code>s.&nbsp;
For instance, with a list of names, your <code>TEXT</code> may become: “insert name” “copy name” “cut name” “paste name” “delete name”,
and your confirm dialog may become “Do you want to delete this name?”.&nbsp;
Embedded JavaScript<mark class='macronym'>™</mark> event-handler attributes may also be modified and/or expanded as appropriate to your needs;
however, note the FormFieldGenie copies these “onclick” and all other attributes as it auto-creates new <code>&lt;li&gt;</code> items for each new “clip”
the end-user copies/cuts to.&nbsp;
As an example of a difference, you may want the end-user to double or even triple-click to delete, and then do it with no confirmation:
<code>onclick='if (event.detail===3) myGenie.deleteField(this.closest("."+myGenie.config.groupClass))'</code>.</p>
<code>
&lt;menu id='myGenie_popUpMenu' standardItems='genie'&gt;
  &lt;li&gt;insert:&lt;span onclick='myGenie.popNewField(this.closest("."+myGenie.config.groupClass), {doso:"insert"})'&gt;empty field&lt;/span&gt;
              &lt;ul onclick='if (event.phase===Event.BUBBLING_PHASE) myGenie.pasteField(this.closest("."+myGenie.config.groupClass), {doso:"insert", clip:event.target.className})'&gt;
                &lt;li class='genie'&gt;all clips&lt;/li&gt;
              &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;copy to:&lt;ul onclick='if (event.phase===Event.BUBBLING_PHASE) myGenie.copyField(this.closest("."+myGenie.config.groupClass), {clip:event.target.className})'&gt;
                &lt;li class='genie'&gt;new clip&lt;/li&gt;
              &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;cut to:&lt;ul onclick='if (event.phase===Event.BUBBLING_PHASE) myGenie.cutField(this.closest("."+myGenie.config.groupClass), {clip:event.target.className})'&gt;
                &lt;li class='genie'&gt;new clip&lt;/li&gt;
              &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;paste from:&lt;ul onclick='if (event.phase===Event.BUBBLING_PHASE) myGenie.pasteField(this.closest("."+myGenie.config.groupClass), {clip:event.target.className})'&gt;
                &lt;/ul&gt;&lt;/li&gt;
  &lt;li onclick='if (confirm("Do you want to delete this fieldNodeGroup?")) myGenie.deleteField(this.closest("."+myGenie.config.groupClass))'&gt;delete&lt;/li&gt;
  &lt;li onclick='myGenie.clearClipboard();'&gt;clear clipboard&lt;/li&gt;
&lt;/menu&gt;
</code>
<p>Your webpage JavaScript<mark class='macronym'>™</mark> code should further manage this <abbr>HTML</abbr> menu, typically moving it “into” the <code>fieldNodeGroup</code> <abbr>HTML</abbr>
when the end-user right-clicks (menu-clicks) in said <code>fieldNodeGroup</code>,
and style it with <abbr>CSS</abbr> so it “pops-up” (appears) at the right place at that time.&nbsp;
It would typically need additional Event handlers added to it so it “pops down” (disappears) when a selection is made;
and/or Event-handlers attached to the body to do the same thing if clicked elsewhere, or another form-field somewhere else gets focus, etc.</p>


<h2>The publicly accessible <topic>properties</topic> of a FormFieldGenie instance are:</h2>
<dl>
	<dt>.config</dt>
		<dd>An instance of a <a href='#config_stack'>FormFieldGenie.ConfigStack</a>.&nbsp;
		This holds all the configuration values for a FormFieldGenie instance.&nbsp;
		You can <code>myGenie.config.stack()</code> a new set of values (of your choice) onto the stack to temporarily change them,
		then <code>myGenie.config.cull()</code> off those modifications to restore the configuration to the previous values.&nbsp;
		Any time you pass an <var>opts</var> (options) object to any method, those options are temporarily stacked
		onto this stack while the method is operating.</dd>
	<dt>.clipboard</dt>
		<dd>This holds all the clipboard data for your Genie instance.</dd>
	<dt>.HTML_clipmenu</dt>
		<dd>This holds the <abbr>HTML</abbr> that is the “menu” shown to the end-user with the clipboard data for your Genie instance.</dd>
	<dt>.tabbedOut</dt>
		<dd>this <code>Boolean</code> value indicates if the end-user pressed the <kbd><span>Tab</span></kbd> key to exit a form field.</dd>
</dl>

<h2>The publicly accessible <topic>user methods</topic> of a FormFieldGenie instance are:</h2>
<dl>
	<dt>popNewField(fieldNodeGroup, opts)</dt>
		<dd>Returns <code>true</code> if a new <code>fieldNodeGroup</code> is ‘popped’ or <code>false</code> if not.</dd>
	<dt>deleteField(fieldNodeGroup, opts)</dt>
		 <dd>Returns <code>true</code> if the <code>fieldNodeGroup</code> was deleted, <code>false</code> if not.</dd>
	<dt>cutField(fieldNodeGroup, opts)</dt>
		 <dd>Returns <code>true</code> if the <code>fieldNodeGroup</code> was deleted, <code>false</code> if not.<br>
			<code>fieldNodeGroup</code> will always be copied to the clipboard.</dd>
	<dt>copyField(fieldNodeGroup, opts)</dt>
		 <dd>Returns <code>null</code>.<br>
		 <code>fieldNodeGroup</code> will always be copied to the clipboard.</dd>
	<dt>pasteField(fieldNodeGroup, opts)</dt>
		 <dd>Returns <code>false</code> if the clipboard clip is empty, <code>true</code> if it is pasted.</dd>
	<dt>clearClipboard()</dt>
		 <dd>Does what it says.</dd>
	<dt>getClip(clipID, doInit)</dt>
		 <dd>This method is also called internally by other user-methods as a worker-method, but you may utilize it if manually working with the clipboard.</dd>
	<dt>update_HTML_clipMenu()</dt>
		 <dd>This method is also called internally by other user-methods as a worker-method, but you may utilize it if manually updating the clipboard.</dd>
</dl>

<h2>The publicly accessible (and user-replacable) <topic>worker-methods</topic> of a FormFieldGenie instance are:</h2>
<dl>
	<dt>isActiveField(fieldNode, cbParams)</dt>
		<dd>This is called internally by user methods.&nbsp;
		You can replace it using something like: <code>myGenie.isActiveField=function(fieldNode, cbParams)  { /*…your customizing code…*/ }</code>
		The standard function also recognizes <code>myGenie.config.isActiveField</code> which may be a function or Boolean value.&nbsp;
		This can replace the standard function to check if a form field is currently active or not;
		i.e. is it disabled, or is it even displayed at all?&nbsp;
		You may add/subtract your own rules, perhaps checking the status of another element.&nbsp;
		Inactive elements will not be considered when deciding to pop a new fieldNodeGroup or dump an empty one.&nbsp;
		The <var>cbParams</var> variable is the user’s call-back parameters
		(see <code>cbParams</code> below in the <a href='#config_stack'>ConfigStack</a> description below).&nbsp;
		Your function should return <code>true‖false</code>.</dd>
	<dt>catchTab(event)</dt>
		<dd>This is to be utilized (called by) by your “onKeyDown” event handler.&nbsp;
		It can also <strong><em>be</em></strong> the “onKeyDown” event handler if you attach it using <code>Element.addEventListener()</code>
		as opposed to the handler being an Element's attribute.</dd>
	<dt>catchKey(event)</dt>
		<dd>This is <strong><em>not</em></strong> defined natively, but is recognized by the standard
		<code>catchTab()</code> method of an instance.&nbsp;
		Since the form field that the event-handler (i.e. <code>catchTab()</code>, which calls this method) is attached to is likely to be cloned,
		it is easier to attach event-handlers “inline”, i.e. a part of the HTML tag as an “onkeydown” attribute
		(e.g. <code>&lt;input type='text' onkeydown='myGenie.catchTab(event)'&gt;</code>),
		so said attribute that leads to calling this method is inclusively cloned,
		rather than using “unobtrusive” JavaScript<mark class='macronym'>™</mark> <code>addEventListener()</code> methods every time the form field is cloned.&nbsp;
		This conception, however, limits you to only one (1) “onkeydown” event handler,
		so the “catchKey” hook is internal to allow you to “use” additional “onkeydown” handlers without having to add them to the element.&nbsp;
		Alternatively, you may utilize the “<code>myGenie.config.eventRegistrar()</code>” functional option (see the ConfigStack options below)
		to add on a handler that calls this method, or any additional handlers, to newly cloned form fields as needed.</dd>
</dl>

<h2 id='config_stack'>The publicly accessible properties and <default>default values</default>
of a <topic>FormFieldGenie.ConfigStack</topic> (myGenie.config) instance are:</h2>

<dl>
	<dt>indxTier: <var>0 +number</var> <default>0</default></dt>
		<dd>Number of index “tiers” to ignore at the end of a name; used to skip over tier(s) when updating names.&nbsp;
		<code>climbTiers</code> must be true (see directly below).&nbsp;
		Example:  name → <code>myField[4][3][2]</code> when <code>indxTier=2</code> the FormFieldGenie updates/modifies the index that contains “4”.&nbsp;
		Note the Genie looks for the <strong><em>next</em> numeric</strong> index, so note the following
		example:  name → <code>myField[4][subsection][3][2]</code>  when <code>indxTier=2</code> the FormFieldGenie updates/modifies the index that contains “4”.
		</dd>

	<dt>climbTiers: <code><default>true</default> ‖ false</code></dt>
		<dd>¿Check all levels (tiers) of indices for a numeric value, or only the last?&nbsp;
		See <code>indxTier</code> directly above.</dd>

	<dt>updateValue: <code>"non-implicit" ‖ "non-indexed" ‖ "indexed" ‖ "implicit" ‖ <default>"all"</default></code></dt>
		<dd>Controls the application of updating <strong><code>values</code></strong> instead of <strong><code>names</code></strong> in
		checkbox and radio-button fields that have <strong><code>values</code></strong> formatted similar to “<code>[0]</code>”&nbsp;
		Any other (string value) condition passed yields no values updated.&nbsp;</dd>
		<span class='notice'>===↓ examples ↓===</span><pre>
		all             name  name[string]  name[number]  name[]
		non-implicit    name  name[string]  name[number]
		non-indexed     name
		indexed         name[string]  name[number]
		implicit        name[]
		</pre>
		<span class='notice'>===↑ examples only show final indices or lack of; indexed names may have additional indices ↑===</span></dd>

	<dt>focusField: <var>0 +number</var> <default>0</default></dt>
		<dd><em>This applies to <code>pasteField()</code> and <code>popNewField()</code> only.</em>
		Pass the field number (counted from <strong><em>zero</em></strong>)
		of the text/filename field you want the cursor focused on,
		<strong>if</strong> the user pressed the <kbd><span>Tab</span></kbd> key
		or <code>config.doFocus=true</code> (see directly below),
		when popping or when pasting a new fieldNodeGroup.</dd>

	<dt>doFocus: <code>true ‖ false ‖ <default>null</default></code></dt>
		<dd><em>This applies to <code>pasteField()</code> and <code>popNewField()</code> only.</em>
		If <code>true</code>, the <code>focusField</code> (see directly above)  will receive focus,
		whether or not the <kbd><span>Tab</span></kbd> key was pressed.&nbsp;
		If <code>false</code>, the <code>focusField</code> will not receive focus when the <kbd><span>Tab</span></kbd> key is pressed.&nbsp;
		If <code>null</code>, then the <kbd><span>Tab</span></kbd> key will cause the <code>focusField</code> to receive focus
		when popping a new <code>fieldNodeGroup</code>.</dd>

	<dt>isActiveField: <code><default>undefined</default> ‖ true ‖ false ‖
	function(fieldNodeGroupInQuestion, cbParams) { /*…your custom code makes the distinction…*/ }</code></dt>
		<dd>This works in conjunction with the <code>isActiveField()</code> <strong>method</strong> of a FormFieldGenie instance.&nbsp;
		If <code>true</code>, all form fields will be considered active; if <code>false</code> they will not.&nbsp;
		If this value is a user-defined function, its Boolean return value will be respected.&nbsp;
		The <code>cbParams</code> variable is the user’s options (see below).</dd>

	<dt>dumpEmpties: <code><default>dumpEmpties()</default> ‖ true ‖ false ‖
	function(empty_fieldNodeGroupInQuestion, deleteFlag) { /*…your custom code makes the distinction…*/ }</code></dt>
		<dd>Remove emptied fieldNodeGroups on the fly?
		<em>This applies to <code>deleteField()</code> and <code>popNewField()</code> only, and not when inserting or pasting.</em>
		The supplied default function utilizes the <code>minFields</code>, <code>groupTag</code>, &amp; <code>groupClass</code>
		ConfigStack values (see below) to make the distinction.&nbsp;
		If a function is supplied, it should return <code>true ‖ false ‖ null</code>
		and if <code>null</code> is returned, the function should remove the field itself.&nbsp;
		If you use <code>deleteField()</code>, the <code>fieldNodeGroup</code> will be removed
		even if <code>dumpEmpties===false</code>;&nbsp;
		however, if <code>dumpEmpties</code> is a function, it will be called with the value of
		<code>deleteFlag=true</code> as its second parameter
		and its return value (<code>true‖false</code>) will be respected.
		</dd>

	<dt>minGroups: <var>+number</var> <default>1</default></dt>
		<dd>Min number of “fieldNodeGroups” when checking to dump empties
		using the standard <code>dumpEmpties()</code> function (see directly above).</dd>

	<dt>maxGroups: <var>+number</var> <default>100</default></dt>
		<dd>Maximum number of clones (<code>fieldNodeGroups</code>) in the <code>fieldNodeGroupFieldset</code>.</dd>

	<dt>groupClass: <var>string ‖ RegExp</var> <default>""</default></dt>
		<dd>This is used to identify <strong>specific</strong> Elements in a <code>fieldNodeGroupFieldset</code> that are <code>fieldNodeGroup</code>s.&nbsp;
		If it is undefined, all children of the <code>fieldNodeGroupFieldset</code> are <code>fieldNodeGroup</code>s if they match the <code>ConfigStack.groupTag</code>.</dd>

	<dt>groupTag: <code>htmlTagNameString.toUpperCase() ‖ <default>null</default></code></dt>
		<dd>This is used to identify <strong>specific</strong> Elements in a <code>fieldNodeGroupFieldset</code> that are <code>fieldNodeGroup</code>s.&nbsp;
		If it is undefined, all children of the <code>fieldNodeGroupFieldset</code> are <code>fieldNodeGroup</code>s if they match the <code>ConfigStack.groupClass</code>.</dd>

	<!--  dt>nodeName: <default>null</default></dt>
		<dd>Specific nodeName of <code>fieldNode</code> Elements to check for being “empty” when checking to dump empties
		using the standard <code>dumpEmpties()</code> function (see directly above).&nbsp;
		Remember, in JavaScript<mark class='macronym'>™</mark> node names are in all UPPERCASE.</dd  -->

	<dt>checkForFilled: <code>"all" ‖ "some" ‖ "any" ‖ <default>"one"</default></code></dt>
		<dd><em>This applies to <code>deleteField()</code> and <code>popNewField()</code> only, and <strong>not</strong> when inserting or pasting.</em>
		If set, the corresponding specified input-fields in the <code>fieldNodeGroup</code> will be checked.&nbsp;
		By default only the <strong><em>first</em></strong> one is checked.&nbsp;
		If <code>one</code> or <code>some</code> or possibly <code>any</code>, the <code>checkField</code> option (see below) should be used also.
		<dl>
				<dt>'one'</dt>
				<dd><desc>the “specified field” is indexed by <code>checkField</code></desc>
					<rule>if the one specified field is full, a new group is popped.</rule>
					<rule>if the one specified field is empty, the group may be dumped (automatically deleted).</rule></dd>
				<dt>'any'</dt>
				<dd><desc>the “specified fields” are either all of the fields in the group,
					or if <code>checkField</code> is an array, it should contain the numeric indices of the fields</desc>
					<rule>if any one of the specified fields is full, a new group is popped.</rule>
					<rule>if all of the specified fields are empty, the group may be dumped (automatically deleted).</rule></dd>
				<dt>'some'</dt>
				<dd><desc>each of the -first- "checkField" number of fields specified will be checked,
					or if <code>checkfield</code> is an array, it should contain the numeric indices of the fields</desc>
					<rule>if all of the specified fields are full, a new group is popped.</rule>
					<rule>if all of the specified fields are empty, the group may be dumped (automatically deleted).</rule></dd>
				<dt>'all'</dt>
				<dd><rule>if all of the fields in the group are full, a new group is popped.</rule>
					<rule>if all of the fields in the group are empty, the group may be dumped (automatically deleted).</rule></dd>
		</dl></dd>

	<dt>checkField: <var>0, +number</var> ‖ <var>Array</var> <default>0</default></dt>
		<dd><em>This applies to <code>deleteField()</code> and <code>popNewField()</code> only, and <strong>not</strong> when inserting or pasting.</em>
		Used in conjunction with <code>checkForFilled</code> (see above).
		<ul>
			<li><desc>if checkField is a number (when <code>checkForFilled</code> = 'one' ‖ 'some')</desc>
				<rule>Pass the field number (counted from <strong><em>zero</em></strong>)
				of the field or fields you want checked for being “empty” when popping.&nbsp;
				If <code>checkForEmpty='some'</code> then each of the first <var>number</var> of fields will be checked.</rule></li>
			<li><desc>if checkField is an Array (when <code>checkForFilled</code> = 'any' ‖ 'some')</desc>
				<rule>The array should contain numeric values that are the indices of the fields to check.&nbsp;
				The fields are indexed (starting with <strong><em>0</em></strong>) in the order that they appear in the <abbr>HTML</abbr> document.</rule></li>
		</ul>
		</dd>

	<dt>cbParams:<var>variable</var> <default>undefined</default></dt>
		<dd>This is a user-defined object/value of any type.&nbsp;
		This property is not defined (e.g. <code>(cbParams in myGenie.config)===false)</code>) unless defined by the user.&nbsp;
		This will be passed through to the <code>updateName</code> plugin callback function as the fourth variable (<var>cbParams</var>),
		and to the <code>isActiveField</code>†, <code>cloneCustomizer</code>‡, <code>eventRegistrar</code>‡ and <code>fieldsetCusomizer</code>‡
		plugin callback functions as the †second or ‡third.&nbsp;
		It may be any type as required by your plugin callback functions,
		but if they share you may want to use an object with separate properties.</dd>

	<dt>updateName: <code><default>null</default> ‖ function(field, indxOffset, fieldNodeGroupFieldset, cbParams)  { /*your plugin code*/ }</code></dt>
		<dd>A plugin callback function to handle the process of updating each name.&nbsp;
		The function will be passed each individual form <abbr>DOM</abbr> object
		(<code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code> or <code>&lt;select&gt;</code> or <code>&lt;button&gt;</code>)
			one at a time in the <code>field</code> variable.&nbsp;
		The <code>indxOffset</code> variable contains the numerical positional offset
			of the new <code>field</code> compared to the <code>field</code> passed in.&nbsp;
		The <code>cbParams</code> variable is the user’s options (see above).
		The Function should pass back a string of the new name, or <code>null</code>.
		If a string is returned, the name attribute of the <abbr>DOM</abbr> object will be set to that value;
			no need for your function to alter the name directly, unless returning <code>null</code>.
		If <code>null</code> is returned, the usual process of updating the name continues.&nbsp;
		The <code>updateName()</code> function may do anything it needs from partial updating the name directly
		(to be continued by the usual process), to updating the <code>value</code>, to updating the parentNode text, or whatever you can imagine…</dd>

	<dt>cloneCustomizer: <code><default>null</default> ‖ function(fieldNodeGroup, pasteOver, cbParams)  { /*your customizing code*/ }</code></dt>
		<dd>If there is something special you want to do to each nodeGroup cloned, you may pass a function to handle that.&nbsp;
		All field names will have been updated, but the node will not yet have been added to the document.&nbsp;
		The passed variable <code>pasteOver</code> will be (<code>true ‖ false ‖ 'paste-over'</code>)&nbsp;
		—&nbsp; <code>true</code> if pasting <strong><em>and</em></strong> inserting,
		<code>'paste-over'</code> if pasting <strong><em>over</em></strong> an existing <code>fieldNodeGroup</code> (the old existing one will be discarded).&nbsp;
		The <code>cbParams</code> variable is the user’s call-back parameters (see <code>cbParams</code> above).&nbsp;
		This Function is called only when a new <code>fieldNodeGroup</code> is being popped or pasted over.</dd>

	<dt>eventRegistrar: <code><default>null</default> ‖ function(fieldNodeGroup, pasteOver, cbParams)  { /*your customizing code*/ }</code></dt>
		<dd>While <abbr>HTML</abbr> attributes including event handlers are cloned when a <acronym>DOM</acronym> node is cloned,
		<abbr>DOM</abbr> level 2+ event handlers are <strong>not</strong> cloned.&nbsp;
		If you need event handlers registered for any elements in your cloned fieldNodeGroup,
		you must do them “by hand” through this function.&nbsp;
		The function will be passed the <code>fieldNodeGroup</code> <strong>after</strong> it has been added to the document.&nbsp;
		See <code>cloneCustomizer</code> (above) for info on <code>pasteOver</code> and <code>params</code>.&nbsp;
		This Function is called only when a new <code>fieldNodeGroup</code> is being popped or pasted over.</dd>

	<dt>fieldsetCustomizer: <code><default>null</default> ‖ function(fieldNodeGroupFieldset, pasteOver, cbParams)  { /*your customizing code*/ }</code></dt>
		<dd>This is called when a new fieldNodeGroup is being popped, pasted,
		or when a fieldNodeGroup is deleted or was empty and has been dumped.&nbsp;
		It is called from a <code>setTimeout()</code> function, so the <abbr>DOM</abbr> will be fully updated.&nbsp;
		Use it to do any final customizing.&nbsp;
		Note it is passed the <strong>whole</strong> <code>fieldNodeGroupFieldset</code> node containing all <code>fieldNodeGroup</code>s
		including the new one after it has been added to the document, not simply the newly cloned group.&nbsp;
		See <code>cloneCustomizer</code> (above) for info on <code>pasteOver</code> and <code>params</code>.</dd>

	<dt>minPixWidth: <var>0, +number</var> <default>4</default></dt>
		<dd>for an input to be "active"</dd>

	<dt>minPixHeight: <var>0, +number</var> <default>4</default></dt>
		<dd>for an input to be "active"</dd>

	<dt>clone: <var>HTMLElement</var> <default>null</default></dt>
		<dd>This is the Node (including children) that will be cloned when popping a new field/fieldset.&nbsp;
		If <code>null</code> then the last <code>fieldNodeGroup</code> will be cloned instead.</dd>

	<dt>clip: <var>string</var> <default>"_FormFieldGenie_system_"</default></dt>
		<dd>Used if you cut/copy/paste w/out specifying the clipboard “clip” name.</dd>

	<dt>only_clips_inAll: <code><default>true</default> ‖ false</code></dt>
		<dd>When using <code>Genie.getClip('all clips')</code>, ¿ only return the whole clipboard.clips array ?</dd>

	<dt>no_system_inAllClips: <code><default>true</default> ‖ false</code></dt>
		<dd>When using <code>Genie.getClip('all clips')</code>, ¿ avoid clips with names that contain _system_ ?</dd>

	<dt>userDataInputTypes: <default>['text', 'search', 'tel', 'url', 'email', 'password', 'datetime', 'date',
	'month', 'week', 'time', 'datetime-local', 'number', 'color', 'file']</default></dt>
		<dd>An array that specifies which <code>&lt;input&gt;</code> “types” the FormFieldGenie recognizes
		as having values defined by the user.</dd>
</dl>

<h2 id='options'>Passing Options to the FormFieldGenie</h2>

<p>Passing options to this class is simple: use an object with properties named accordingly.&nbsp;
Any properties may be included or not, making it simple to control any option without worrying about the others.&nbsp;
If you are not so familiar with JavaScript<mark class='macronym'>™</mark>, pay close attention to the
demonstration example and how to define an object right in the event handler text.&nbsp;
You can also define your object in a separate <code>&lt;script&gt;&lt;/script&gt;</code>,
then simply pass it to the class by name.&nbsp; If you don’t understand how to do this,
please refer to a good book on JavaScript<mark class='macronym'>™</mark> programming.</p>

<p>Options may be defined or passed at three levels: global defaults, instance defaults, and when calling a method.&nbsp;
The FormFieldGenie class’ methods, <code>popNewField()</code>, <code>cutField()</code>, <code>copyField()</code>,
<code>pasteField()</code>, and <code>deleteField()</code>, only take two parameters
(the <code>fieldNodeGroup</code> and the <code>opts</code> options object).&nbsp; By setting the option values of the
<code>FormFieldGenie.ConfigStack.prototype</code> property, you can control the option defaults globally.&nbsp;
When creating an instance (<code>myGenie = new&nbsp;SoftMoon.WebWare.FormFieldGenie( { ...options... } )</code>)
you can override the global defaults, and when calling instance methods you can override the instance defaults.&nbsp;
However, some options only apply to specific methods <strong>as they are being called</strong>;
any similar option in the <a href='#config_stack'>ConfigStack</a> will be ignored.</p>

<p>The <topic>options</topic> object may contain any properties found in the <a href='#config_stack'><code>FormFieldGenie.ConfigStack</code></a>
(others will be ignored).&nbsp;
Some (as noted) will be ignored if passed when creating a new FormFieldGenie instance
and are only valid when calling a method;
those “methodical” properties are noted below:</p>
<dl>
	<dt>doso: <code>true ‖ 'insert' ‖ 'paste'</code></dt>
		<dd><em>This applies to popNewField() and pasteField() only.</em>
		If you pass (Boolean) <code>true</code> when using popNewField(),
		a new <code>fieldNodeGroup</code> will be popped at the end of the <code>fieldNodeGroupFieldset</code>
		regardless of whether the last <code>fieldNodeGroup</code> is empty;&nbsp;
		but not exceeding <code>maxGroups</code>.&nbsp;
		Empty <code>fieldNodeGroup</code>s may be removed as usual.&nbsp;
		Empty <code>fieldNodeGroup</code>s will <strong><em>not</em></strong> be
		automatically removed if <code>"insert"</code> when using popNewField().&nbsp;
		If you pass <code>"insert"</code> or <code>"paste"</code> when using popNewField(),
		a new field will be popped and inserted
		<strong><em>before</em></strong> the passed <code>fieldNodeGroup</code>,
		regardless of whether the last field is empty; but not exceeding <code>maxGroups</code>.<br>
		With <code>popNewField()</code>, “insert” inserts an empty fieldNodeGroup.<br>
		With <code>pasteField()</code>, “insert” inserts the selected clip.<br>
		With <code>popNewField()</code>, “paste” inserts the selected clip.</dd>

	<dt>addTo: <code>true</code></dt>
		<dd><em>This applies to popNewField() and pasteField() only.</em>
		If you pass <code>opts.addto=true</code>, then the value that would be passed into <code>popNewField()</code> as
		<code>fieldNodeGroup</code> will be instead considered the <code>fieldNodeGroupFieldset</code>.&nbsp;
		This will allow you to add a new <code>fieldNodeGroup</code> to an empty <code>fieldNodeGroupFieldset</code>
		but only if •the <code>myGenie.config.clone</code> is set; •or <code>opts.doso='paste'</code> while the clipboard has contents.&nbsp;
		Passing <code>opts.addto=true</code> acts similar as passing <code>opts.doso=true</code> in that it will always pop a new field
		(unless as noted above the <code>fieldNodeGroupFieldset</code> is empty and there is no clone and no paste).&nbsp;
		Note that <code>pasteField()</code> with <code>opts.doso='insert'</code> internally calls calls <code>popNewField()</code>,
		and this option may then take effect.</dd>

	<dt>clip: <var>number</var> ‖ <var>string</var></dt>
		<dd>Object-member/property-identifier — ( a.k.a. <var>%%your-clip-reference%%</var> )<br>
		This is a reference to the member or property of the clipboard object associated with an instance of the FormFieldGenie.&nbsp;
		Each FormFieldGenie instance has its own clipboard, and each clipboard can hold an “unlimited” number of clips
		(limited by the machine).&nbsp;
		You may copy, cut and paste into/from any clip.</dd>
</dl>

<p>Most of these options do not need much more explanation, especially if you study the demonstration example.&nbsp;
A few do, so we will touch on them here.</p>

<p>By using the <code>config.groupClass</code> and/or <code>config.groupTag</code> options, you may include other tags in your
<code>fieldNodeGroupFieldset</code>, including form-inputs or tags with form-inputs as children,
that are not to be duplicated, automatically cleared, or otherwise messed-with by the Genie.</p>

<p>When you want to use a plugin function to update names, you may write one that accepts
a set of parameters, and then pass different parameters to your plugin for different form fields.&nbsp;
There is an included plugin with the demonstration example and the downloadable source code that
shows how this works.&nbsp;
The supplied standard demo plugin can accept two different parameters (passed in the one object).&nbsp;
You may create your own “order” and pass it through to this plugin, should you choose.&nbsp;
If you understand Perl compatible regular expressions, and can understand how this simple plugin functions,
then you could also pass a custom RegExp to the plugin and have even greater control over how it updates the name.&nbsp;
We chose using the first index, because this works well with this plugin’s logic.&nbsp;
Pay attention to the fact that the logic requires matching a <strong>single</strong> character,
then the “incremental word” follows.&nbsp; Another example of a naming style that would work
with this function’s logic is <code>name_first</code>&nbsp; <code>name_second</code>
using the RegExp <code>/_([a-z]+)$/</code> or <code>name_first[]</code>&nbsp; using <code>/_([a-z]+)\[/</code></p>
</main>

<footer>
<p>SoftMoon-WebWare and its websites do not use or store “cookies” or other data on your computer/device
(except for application demos that require your intent to do so, to store “settings” and the data you generate and desire to save).&nbsp;
No personal data is transferred to any other entity
(except with your intent as previously stated while using “demos”,
and said data is only transferred to SoftMoon-WebWare.com and is <em>not</em> saved).&nbsp;
You are not being tracked, quantified, or mined for data when visiting our sites.&nbsp;
We hope you enjoy the advertisement-free experience that shuns the growing worldwide corporate-fascism movement.</p>
<p>All content found on this page &amp; site Copyright © 2010, 2012, 2013, 2015, 2022  by SoftMoon-WebWare and its owner,
all rights reserved, unless otherwise specifically noted.&nbsp;
Trademarks and Service-Marks are property of SoftMoon-WebWare and its owner,
all rights reserved, unless otherwise specifically noted.</p>
<p>
<note>“JavaScript” is a trademark of Oracle Corporation.</note>
</p>
</footer>
</body>
</html>
